Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.
You may not alter the values in the list's nodes, only nodes themselves may be changed.

Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

Code:
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {       
            ListNode begin = null;
            ListNode dummy = new ListNode(-1);
            dummy.next = head;
            begin = dummy; int i=0;

            while(head != null){
                i++;
                if(i%k == 0){
                    begin = reverse(begin, head.next);
                    head = begin.next;
                }else{
                    head = head.next;
                }
            }
      return dummy.next;
    }
    private ListNode reverse(ListNode begin, ListNode end){             
                  ListNode curr = begin.next;
                  ListNode prev = begin;
                  ListNode first = curr;
                  ListNode next;

                  while(curr != end){
                     next = curr.next;
                     curr.next = prev;
                     prev = curr;
                     curr = next;
                  }
                  begin.next = prev;
                  first.next = curr;
                  return first;
    }
}

Time and Space Complexity:
Time: O(N) — each node is visited and reversed exactly once.
Space: O(1) — in-place reversal, no extra data structures used.
