Given a binary grid[][], where each cell contains either 0 or 1, find the distance of the nearest 1 for every cell in the grid.
The distance between two cells (i1, j1)  and (i2, j2) is calculated as |i1 - i2| + |j1 - j2|. 
You need to return a matrix of the same size, where each cell (i, j) contains the minimum distance from grid[i][j] to the nearest cell having value 1.
Note: It is guaranteed that there is at least one cell with value 1 in the grid.
Examples
Input: grid[][] = [[0, 1, 1, 0], 
                [1, 1, 0, 0], 
                [0, 0, 1, 1]]
Output: [[1, 0, 0, 1], 
        [0, 0, 1, 1], 
        [1, 1, 0, 0]]
Explanation: The grid is -
- 0's at (0,0), (0,3), (1,2), (1,3), (2,0) and (2,1) are at a distance of 1 from 1's at (0,1), (0,2), (0,2), (2,3), (1,0) and (1,1) respectively.

Code:
class Solution {
    public ArrayList<ArrayList<Integer>> nearest(int[][] grid) {
        // code here
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        
        for(int i=0;i<grid.length;i++){
            ArrayList<Integer> al = new ArrayList<>();
            for(int j=0;j<grid[i].length;j++){
                int num = findOne(grid, i, j);
                al.add(num);
            }
            ans.add(al);
        }
        
        return ans;
    }
    
    int findOne(int[][] grid, int a, int b){
        int len = grid.length * grid[0].length;
        
        for(int n=0;n<len;n++){
            int i=0, j=n;
            
            while(i<=n){
                if(a-i>=0 && b-j>=0 && grid[a-i][b-j]==1){
                    return i + j;
                }
                
                if(a-i>=0 && b+j<grid[0].length && grid[a-i][b+j]==1){
                    return i + j;
                }
                
                if(b-j>=0 && a+i<grid.length && grid[a+i][b-j]==1){
                    return i + j;
                }
                
                if(a+i<grid.length && b+j<grid[0].length && grid[a+i][b+j]==1){
                    return i + j;
                }
                
                i++;
                j--;
            }
        }
        
        return 0;
    }
}
